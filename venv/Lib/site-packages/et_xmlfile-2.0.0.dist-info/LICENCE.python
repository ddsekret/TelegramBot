import os
import re
import logging
import asyncio
import yadisk
from aiogram import Bot, Dispatcher, types
from aiogram.filters import Command
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton, InlineKeyboardButton, InlineKeyboardMarkup
from aiogram.fsm.state import State, StatesGroup
from aiogram.filters.state import StateFilter
from aiogram.fsm.context import FSMContext
from openpyxl import Workbook, load_workbook
from openpyxl.styles import Font, Alignment, PatternFill, Border, Side
from openpyxl.utils import get_column_letter
from datetime import datetime
from dotenv import load_dotenv
from aiogram.utils.markdown import hbold

# Загрузка переменных окружения
load_dotenv()
TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN", "8116572683:AAGxf2ttP-58uts18pRjTIy9cHX0LZfyUsU")
YANDEX_DISK_TOKEN = os.getenv("YANDEX_DISK_TOKEN", "y0__wgBELawpyAYkbY0IKiM5oQSstnwahr424ZzdNX_Y9dCWfPK-ac")
LOCAL_TEMP_DIR = "temp_files"

# Настройка логирования
logging.basicConfig(
    level=logging.DEBUG,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)

# Инициализация бота и хранилища
storage = MemoryStorage()
bot = Bot(token=TELEGRAM_BOT_TOKEN)
dp = Dispatcher(storage=storage)
y_disk = yadisk.YaDisk(token=YANDEX_DISK_TOKEN)

# Создание временной директории
os.makedirs(LOCAL_TEMP_DIR, exist_ok=True)

# Словари преобразований
CAR_BRANDS = {
    "даф": "DAF", "вольво": "Volvo", "камаз": "КамАЗ", "маз": "MAZ",
    "скания": "Scania", "мерседес": "Mercedes", "ман": "MAN", "фрейтлайнер": "Freightliner",
    "мерседес-бенц": "Mercedes-Benz"
}

KEYWORDS_SYNONYMS = {
    "Фирма": ["фирма", "компания", "фирма-заказчик", "заказчик", "тк"],
    "Направление": ["направление", "маршрут", "путь", "трасса"],
    "Водитель": ["водитель", "шофёр", "шофер", "ф.и.о.", "имя"],
    "Паспорт": ["паспорт", "паспортные данные", "паспорт рф", "серия", "номер"],
    "Водительское удостоверение": ["водительское удостоверение", "ву", "в/у", "в.уд.", "права"],
    "Телефон": ["телефон", "контакт", "номер телефона", "тел.", "тел"],
    "Дата рождения": ["дата рождения", "д.р", "д.р."],
    "Адрес регистрации": ["зарегистрирован", "прописан и проживает", "адрес", "прописка"],
    "Марка машины": ["марка машины", "машина", "авто", "автомобиль", "а/м", "тягач", "тс", "транспортное средство"],
    "Прицеп": ["прицеп", "номер прицепа", "полуприцеп", "п/п", "п/пр.", "п/пр"],
    "Перевозчик": ["перевозчик", "экспедитор", "грузоперевозчик"],
    "Цена": ["цена", "стоимость", "тариф"],
    "Оплата": ["оплата", "платеж", "выплата"]
}

# Создаём список всех синонимов для быстрого поиска
ALL_SYNONYMS = [syn.lower() for synonyms in KEYWORDS_SYNONYMS.values() for syn in synonyms]

class Form(StatesGroup):
    text_input = State()
    editing_field = State()

class ExcelManager:
    def __init__(self, base_dir):
        self.base_dir = base_dir
        self.current_month = datetime.now().strftime("%Y_%m")
        self.column_widths = {
            'daily': [15, 25, 25, 50, 25, 50, 25, 25, 15, 25, 15, 25, 15, 15, 15],
            'firms': [15, 25, 25, 50, 15, 18, 18],
            'carriers': [15, 25, 25, 50, 15, 18, 18, 15]
        }
        self.colors = {
            'header': 'FF4F81BD',
            'even_row': 'FFFFFFFF',
            'odd_row': 'FFF2F2F2'
        }

    def get_file_paths(self):
        return {
            'daily': os.path.join(self.base_dir, f'Ежедневник_{self.current_month}.xlsx'),
            'firms': os.path.join(self.base_dir, f'Фирмы-заказчики_{self.current_month}.xlsx'),
            'carriers': os.path.join(self.base_dir, f'Перевозчики_{self.current_month}.xlsx')
        }

    def _set_column_widths(self, sheet, widths):
        for col_idx, width in enumerate(widths, 1):
            sheet.column_dimensions[get_column_letter(col_idx)].width = width + 2

    def _apply_header_style(self, cell):
        cell.font = Font(name='Arial', size=12, bold=True, color='FFFFFF')
        cell.fill = PatternFill(start_color=self.colors['header'], end_color=self.colors['header'], fill_type='solid')
        cell.alignment = Alignment(horizontal='center', vertical='center', wrap_text=True)
        cell.border = Border(
            left=Side(style='medium', color='FF666666'),
            right=Side(style='medium', color='FF666666'),
            top=Side(style='medium', color='FF666666'),
            bottom=Side(style='medium', color='FF666666')
        )

    def _apply_cell_style(self, cell, row_num, align='left', number_format=None):
        cell.font = Font(name='Arial', size=10)
        cell.alignment = Alignment(horizontal=align, vertical='center', wrap_text=True)
        color = self.colors['even_row'] if row_num % 2 == 0 else self.colors['odd_row']
        cell.fill = PatternFill(start_color=color, end_color=color, fill_type='solid')
        cell.border = Border(
            left=Side(style='thin', color='FF666666'),
            right=Side(style='thin', color='FF666666'),
            top=Side(style='thin', color='FF666666'),
            bottom=Side(style='thin', color='FF666666')
        )
        if number_format:
            cell.number_format = number_format

    def ensure_files_exist(self):
        files = self.get_file_paths()
        headers = {
            'daily': ['Дата', 'Фирма', 'Направление', 'Водитель', 'Паспорт_серия_и_номер', 'Паспорт_место_выдачи_дата_код', 'В/У_серия_и_номер', 'В/У_дата_срок', 'Телефон', 'Марка_машины_номер', 'Прицеп_номер', 'Перевозчик', 'Цена', 'Оплата', 'Прочее'],
            'firms': ['Дата', 'Фирма', 'Направление', 'Водитель', 'Цена', 'Оплата_от_фирмы', 'Дата_оплаты', 'Прочее'],
            'carriers': ['Дата', 'Перевозчик', 'Направление', 'Водитель', 'Оплата', 'Номер_платежки', 'Дата_платежа', 'Сумма оплаты', 'Прочее']
        }
        for file_type, path in files.items():
            if not os.path.exists(path):
                wb = Workbook()
                ws = wb.active
                ws.title = self.current_month
                self._set_column_widths(ws, self.column_widths[file_type])
                for col, header in enumerate(headers[file_type], 1):
                    cell = ws.cell(row=1, column=col, value=header)
                    self._apply_header_style(cell)
                wb.save(path)
                logger.info(f"Создан новый файл: {path}")

    def add_record(self, file_path, data, file_type):
        try:
            if not os.path.exists(file_path):
                logger.warning(f"Файл {file_path} не существует, создаём новый")
                self.ensure_files_exist()
            wb = load_workbook(file_path)
            ws = wb.active
            next_row = ws.max_row + 1
            alignments = {
                'Дата': 'center', 'Цена': 'right', 'Оплата': 'right', 'Оплата_от_фирмы': 'right',
                'Сумма оплаты': 'right', 'Прочее': 'left'
            }
            number_formats = {
                'Цена': '#,##0 ₽', 'Оплата': '#,##0 ₽', 'Оплата_от_фирмы': '#,##0 ₽', 'Сумма оплаты': '#,##0 ₽'
            }
            if file_type == 'daily':
                fields = [
                    ('Дата', datetime.now().strftime("%d.%m.%Y")),
                    ('Фирма', data.get('Фирма', 'Не указана')),
                    ('Направление', data.get('Направление', 'Не указано')),
                    ('Водитель', data.get('Водитель', 'Не указан')),
                    ('Паспорт_серия_и_номер', data.get('Паспорт_серия_и_номер', '')),
                    ('Паспорт_место_выдачи_дата_код', data.get('Паспорт_место_выдачи_дата_код', '')),
                    ('В/У_серия_и_номер', data.get('В/У_серия_и_номер', '')),
                    ('В/У_дата_срок', data.get('В/У_дата_срок', '')),
                    ('Телефон', data.get('Телефон', 'Не указан')),
                    ('Марка_машины_номер', data.get('Марка_машины_номер', 'Не указан')),
                    ('Прицеп_номер', data.get('Прицеп_номер', 'Не указан')),
                    ('Перевозчик', data.get('Перевозчик', 'Не указан')),
                    ('Цена', float(data.get('Цена', 0))),
                    ('Оплата', float(data.get('Оплата', 0))),
                    ('Прочее', data.get('Прочее', ''))
                ]
            elif file_type == 'firms':
                fields = [
                    ('Дата', datetime.now().strftime("%d.%m.%Y")),
                    ('Фирма', data.get('Фирма', '')),
                    ('Направление', data.get('Направление', '')),
                    ('Водитель', data.get('Водитель', '')),
                    ('Цена', float(data.get('Цена', 0))),
                    ('Оплата_от_фирмы', ''),
                    ('Дата_оплаты', ''),
                    ('Прочее', data.get('Прочее', ''))
                ]
            elif file_type == 'carriers':
                fields = [
                    ('Дата', datetime.now().strftime("%d.%m.%Y")),
                    ('Перевозчик', data.get('Перевозчик', '')),
                    ('Направление', data.get('Направление', '')),
                    ('Водитель', data.get('Водитель', '')),
                    ('Оплата', float(data.get('Оплата', 0))),
                    ('Номер_платежки', ''),
                    ('Дата_платежа', ''),
                    ('Сумма оплаты', float(data.get('Сумма оплаты', 0))),
                    ('Прочее', data.get('Прочее', ''))
                ]
            for i, (field, value) in enumerate(fields, 1):
                cell = ws.cell(row=next_row, column=i, value=value)
                self._apply_cell_style(cell, next_row, align=alignments.get(field, 'left'), number_format=number_formats.get(field))
                column = cell.column_letter
                if isinstance(value, str) and ws.column_dimensions[column].width is not None:
                    if len(value) > ws.column_dimensions[column].width:
                        ws.column_dimensions[column].width = len(value) + 2
            wb.save(file_path)
            logger.info(f"Запись добавлена в {file_path}")
            return True
        except Exception as e:
            logger.error(f"Ошибка при добавлении записи в {file_path}: {e}")
            return False

class YandexDiskUploader:
    def __init__(self, y_disk):
        self.y_disk = y_disk

    def ensure_path_exists(self, path):
        parts = path.strip('/').split('/')
        current_path = ''
        for part in parts:
            if part:
                current_path += f'/{part}'
                if not self.y_disk.exists(current_path):
                    try:
                        self.y_disk.mkdir(current_path)
                        logger.info(f"Создана директория: {current_path}")
                    except Exception as e:
                        logger.error(f"Ошибка создания директории {current_path}: {e}")
                        raise

    async def upload_files(self, files, message):
        """Загрузка файлов на Яндекс.Диск с уведомлениями"""
        current_month = datetime.now().strftime("%Y_%m")
        remote_path = f"/TransportData/{current_month}"
        
        try:
            self.ensure_path_exists(remote_path)
        except Exception as e:
            logger.error(f"Ошибка структуры: {e}")
            await bot.send_message(chat_id=message.chat.id, text="⚠️ Ошибка создания структуры на Яндекс.Диск.")
            return False

        for file_path in files:
            try:
                if not os.path.exists(file_path):
                    logger.error(f"Файл не найден: {file_path}")
                    continue

                filename = os.path.basename(file_path)
                remote_file = f"{remote_path}/{filename}"

                if self.y_disk.exists(remote_file):
                    try:
                        self.y_disk.remove(remote_file, permanently=True)
                        logger.info(f"Удалён старый файл: {filename}")
                    except Exception as e:
                        logger.warning(f"Не удалось удалить: {e}")

                self.y_disk.upload(file_path, remote_file, overwrite=True)
                logger.info(f"✅ {filename} загружен")
                await bot.send_message(chat_id=message.chat.id, text=f"📤 Файл {filename} успешно загружен на Яндекс.Диск!")
            except Exception as e:
                logger.error(f"Ошибка загрузки {filename}: {e}")
                await bot.send_message(chat_id=message.chat.id, text=f"⚠️ Ошибка загрузки файла {filename} на Яндекс.Диск.")
                return False

        return True

def format_company_name(name):
    forms = {'ооо': 'ООО', 'оао': 'ОАО', 'зао': 'ЗАО', 'ип': 'ИП', 'пао': 'ПАО', 'тк': 'ТК'}
    name = re.sub(r'\s+', ' ', name.strip())
    words = name.split()
    if not words:
        return name
    first_word = words[0].lower()
    if first_word in forms:
        words[0] = forms[first_word]
        words[1:] = [word.capitalize() for word in words[1:]]
    result = ' '.join(words)
    for form_lower, form_upper in forms.items():
        pattern = fr"(?i){form_lower}\s*([а-яё]{2,})"
        result = re.sub(pattern, fr"{form_upper} \1", result)
    return result

def format_phone(phone):
    # Извлекаем только числовую часть из строки
    phone = re.sub(r'[^0-9]', '', phone)
    # Проверяем длину и форматируем
    if len(phone) == 11 and phone.startswith('8'):
        return f"+7 ({phone[1:4]}) {phone[4:7]}-{phone[7:9]}-{phone[9:11]}"
    elif len(phone) == 11 and phone.startswith('7'):
        return f"+7 ({phone[1:4]}) {phone[4:7]}-{phone[7:9]}-{phone[9:11]}"
    elif len(phone) == 10:
        return f"+7 ({phone[:3]}) {phone[3:6]}-{phone[6:8]}-{phone[8:10]}"
    return phone

def process_vehicle_number(number):
    return re.sub(r'\W', '', number.upper())

def parse_by_keywords(text):
    """Простой парсинг текста по ключевым словам с поддержкой составных ключей"""
    data = {}
    # Нормализуем текст: заменяем множественные пробелы на один, убираем лишние пробелы
    normalized_text = re.sub(r'\s+', ' ', text.strip()).lower()
    words = normalized_text.split()
    
    i = 0
    current_key = None
    value_parts = []
    
    while i < len(words):
        # Проверяем, является ли текущее слово или пара слов ключом
        found_key = None
        # Проверяем составные ключи (из двух слов)
        if i + 1 < len(words):
            two_words = f"{words[i]} {words[i+1]}"
            found_key = next((k for k, synonyms in KEYWORDS_SYNONYMS.items() if two_words in [s.lower() for s in synonyms]), None)
            if found_key:
                i += 2  # Пропускаем оба слова ключа
        # Если составной ключ не найден, проверяем одиночное слово
        if not found_key:
            found_key = next((k for k, synonyms in KEYWORDS_SYNONYMS.items() if words[i] in [s.lower() for s in synonyms]), None)
            if found_key:
                i += 1  # Пропускаем одно слово ключа
        
        if found_key:
            # Если у нас уже есть ключ и значение, сохраняем их
            if current_key and value_parts:
                data[current_key] = " ".join(value_parts).strip()
                value_parts = []
            current_key = found_key
        else:
            # Если слово не ключ, добавляем его к значению текущего ключа
            if current_key:
                value_parts.append(words[i])
            i += 1
    
    # Сохраняем последнее значение, если оно есть
    if current_key and value_parts:
        data[current_key] = " ".join(value_parts).strip()

    logger.debug(f"Сырые данные после парсинга: {data}")
    return normalize_data(data)

def normalize_data(data):
    for field in ["Фирма", "Перевозчик"]:
        if field in data and data[field]:
            data[field] = format_company_name(data[field])
    if "Водитель" in data:
        parts = data["Водитель"].split()
        parts = [part.capitalize() for part in parts[:3]]
        data["Водитель"] = " ".join(parts)
    if "Направление" in data:
        parts = re.split(r"[-–—→\s]+", data["Направление"])
        parts = [p.strip().title() for p in parts if p.strip()]
        data["Направление"] = " → ".join(parts)
    if "Марка машины" in data:
        # Объединяем "Марка машины" и "Прицеп", если он есть
        vehicle_text = data["Марка машины"]
        if "Прицеп" in data:
            vehicle_text += f" прицеп {data['Прицеп']}"
            del data["Прицеп"]
        parts = vehicle_text.split("прицеп", 1)
        auto_part = parts[0].strip()
        trailer_part = parts[1].strip() if len(parts) > 1 else ""
        brand_match = re.match(r"(\w+\s*)+", auto_part)
        brand = brand_match.group(0).strip().lower() if brand_match else "Не указана"
        data["Марка_машины_номер"] = f"{CAR_BRANDS.get(brand, brand.title())} {process_vehicle_number(auto_part[len(brand):].strip())}"
        data["Прицеп_номер"] = process_vehicle_number(trailer_part) if trailer_part else "Не указан"
    for field in ["Телефон"]:
        if field in data:
            data[field] = format_phone(data[field])
    for field in ["Цена", "Оплата"]:
        if field in data:
            try:
                raw_value = data[field]
                if isinstance(raw_value, str):
                    numeric = re.sub(r'[^\d.]', '', raw_value)
                    if '.' in numeric:
                        parts = numeric.split('.')
                        if len(parts) > 2:
                            numeric = ''.join(parts[:-1]) + '.' + parts[-1]
                    data[field] = int(float(numeric) * 1000) if numeric else 0
                else:
                    data[field] = int(raw_value)
            except:
                data[field] = 0
    if "Паспорт" in data:
        passport_text = data["Паспорт"]
        series_match = re.match(r"серия\s+(\d+\s+\d+)|(\d+\s+\d+\s+№\s+\d+)", passport_text, re.IGNORECASE)
        number_match = re.search(r"номер\s+(\d+)", passport_text, re.IGNORECASE) if not series_match else None
        issued_match = re.search(r"выдан\s+(.+?)(?:дата\s+выдачи|\,|\n|$)", passport_text, re.IGNORECASE)
        date_match = re.search(r"дата\s+выдачи:\s*(\d{2}\.\d{2}\.\d{4})", passport_text, re.IGNORECASE) or re.search(r"(\d{2}\.\d{2}\.\d{4})(?:\s*г\.)?", passport_text)
        code_match = re.search(r"код\s+подразделения\s+(\d+-\d+)", passport_text, re.IGNORECASE)

        series_number = series_match.group(0) if series_match else re.match(r"(\d+\s+\d+)", passport_text).group(0) if re.match(r"(\d+\s+\d+)", passport_text) else ""
        number = number_match.group(1) if number_match else re.search(r"№\s+(\d+)", passport_text).group(1) if re.search(r"№\s+(\d+)", passport_text) else ""
        issued = issued_match.group(1).strip() if issued_match else ""
        date = date_match.group(1) if date_match else ""
        code = code_match.group(1) if code_match else ""

        data["Паспорт_серия_и_номер"] = f"{series_number} № {number}" if series_number and number else series_number or ""
        data["Паспорт_место_выдачи_дата_код"] = f"{issued}, {date}, {code}" if issued or date or code else ""
        data["Паспорт_серия"] = re.sub(r"\s+№\s+\d+", "", series_number).strip() if series_number else ""
        data["Паспорт_номер"] = number if number else ""
    if "Водительское удостоверение" in data:
        vu_text = data["Водительское удостоверение"]
        series_match = re.match(r"серия\s+(\d+\s+\d+)", vu_text, re.IGNORECASE) or re.match(r"(\d+\s+\d+)", vu_text)
        number_match = re.search(r"номер\s+(\d+)", vu_text, re.IGNORECASE) or re.search(r"№\s+(\d+)", vu_text)
        date_match = re.search(r"от\s+(\d{2}\.\d{2}\.\d{4})", vu_text) or re.search(r"(\d{2}\.\d{2}\.\d{4})(?:\s*г\.)?", vu_text)
        term_match = re.search(r"срок\s+(\d{2}\.\d{2}\.\d{4}-\d{2}\.\d{2}\.\d{4})", vu_text, re.IGNORECASE)

        series = series_match.group(0) if series_match else ""
        number = number_match.group(1) if number_match else ""
        date = date_match.group(1) if date_match else ""
        term = term_match.group(1) if term_match else ""

        data["В/У_серия_и_номер"] = f"{series} № {number}" if series and number else series or ""
        data["В/У_дата_срок"] = f"{date}-{term}" if date or term else ""
    return data

def create_main_menu():
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="📋 Запись")],
            [KeyboardButton(text="📆 Последние записи"), KeyboardButton(text="📊 Статистика")],
            [KeyboardButton(text="📦 Загрузить файл")]
        ],
        resize_keyboard=True
    )

@dp.message(Command("start"))
async def start_command(message: types.Message, state: FSMContext):
    logger.debug("Получена команда /start")
    await state.clear()
    await message.reply(
        "🚚 Транспортный учет\n\n"
        "Нажмите '📋 Запись' для ввода данных в текстовом формате, начиная каждую строку с ключевого слова (например, Фирма, Направление, Водитель и т.д.), за которым следует значение. Используйте любой порядок:\n\n"
        "Пример (можно в одной строке или с переносами):\n"
        "Фирма ТК Оптима Направление Хабаровск → Владивосток Водитель Иванов И.И. Паспорт 58 23 № 452205 В/У 99 21 № 980427 Телефон 911-359-75-34 Марка машины Вольво У444РУ60 Прицеп АУ548647 Перевозчик ООО Ромашка Цена 50000 Оплата 10000\n"
        "Или:\n"
        "Фирма: ТК Оптима\n"
        "Направление: Хабаровск-Владивосток\n"
        "Водитель: Иванов И.И.\n"
        "Паспорт: 58 23 № 452205 выдан УМВД, дата выдачи: 11.05.2023, код 600-002\n"
        "В/У: 99 21 № 980427\n"
        "Телефон: 911-359-75-34\n"
        "Марка машины: Вольво У444РУ60\n"
        "Прицеп: АУ548647\n"
        "Перевозчик: ООО Ромашка\n"
        "Цена: 50000\n"
        "Оплата: 10000\n\n"
        "Если допущена ошибка, бот попросит уточнить данные. Нажмите /start для возврата в меню.",
        reply_markup=create_main_menu()
    )

@dp.message(lambda message: message.text == "📋 Запись")
async def record_start(message: types.Message, state: FSMContext):
    logger.debug(f"Получено сообщение: '{message.text}'. Ожидаемое: '📋 Запись'. Совпадает: {message.text == '📋 Запись'}")
    logger.debug("Нажата кнопка '📋 Запись', устанавливается состояние Form.text_input")
    await state.set_state(Form.text_input)
    await message.reply(
        "📝 Введите данные в текстовом формате, начиная каждую строку с ключевого слова (например, Фирма, Направление, Водитель и т.д.), за которым следует значение. Используйте любой порядок:\n\n"
        "Пример (можно в одной строке или с переносами):\n"
        "Фирма ТК Оптима Направление Хабаровск → Владивосток Водитель Иванов И.И. Паспорт 58 23 № 452205 В/У 99 21 № 980427 Телефон 911-359-75-34 Марка машины Вольво У444РУ60 Прицеп АУ548647 Перевозчик ООО Ромашка Цена 50000 Оплата 10000",
        reply_markup=create_main_menu()
    )

@dp.message(StateFilter(Form.text_input))
async def process_text_input(message: types.Message, state: FSMContext):
    logger.debug(f"Обработка текста в состоянии Form.text_input. Получен текст: '{message.text.strip()}'")
    text = message.text.strip()
    if not text:
        logger.warning("Получен пустой текст")
        await message.reply(
            "⚠️ Пожалуйста, введите данные в текстовом формате, начиная каждую строку с ключевого слова (например, Фирма, Направление, Водитель и т.д.):",
            reply_markup=create_main_menu()
        )
        return

    try:
        data = parse_by_keywords(text)
        logger.info(f"Распознанные данные: {data}")

        required_fields = ["Фирма", "Направление", "Водитель", "Марка_машины_номер", "Перевозчик", "Цена", "Оплата"]
        missing_fields = [field for field in required_fields if not data.get(field)]
        logger.debug(f"Проверяются обязательные поля. Отсутствуют: {missing_fields}")

        if not missing_fields:
            await show_verification_ui(message, data, state)
        else:
            await message.reply(
                f"⚠️ Не распознаны поля: {', '.join(missing_fields)}\n"
                "Пожалуйста, уточните данные:",
                reply_markup=create_main_menu()
            )
    except Exception as e:
        logger.error(f"Ошибка при обработке текста: {e}", exc_info=True)
        await message.reply(
            "⚠️ Произошла ошибка при обработке данных. Пожалуйста, попробуйте снова или обратитесь к администратору.",
            reply_markup=create_main_menu()
        )

@dp.message(StateFilter(Form.editing_field))
async def update_field(message: types.Message, state: FSMContext):
    logger.debug(f"Обновление поля после редактирования. Получен текст: '{message.text.strip()}'")
    data = await state.get_data()
    field = data.get('editing_field')
    new_value = message.text.strip()

    if field in ["Цена", "Оплата"]:
        try:
            numeric = re.sub(r'[^\d.]', '', new_value)
            if '.' in numeric:
                parts = numeric.split('.')
                if len(parts) > 2:
                    numeric = ''.join(parts[:-1]) + '.' + parts[-1]
            new_value = int(float(numeric) * 1000) if numeric else 0
        except:
            new_value = 0

    if field == "Телефон":
        new_value = format_phone(new_value)
    elif field in ["Марка_машины_номер", "Прицеп_номер"]:
        new_value = process_vehicle_number(new_value)
    elif field in ["Фирма", "Перевозчик"]:
        new_value = format_company_name(new_value)
    elif field == "Направление":
        parts = re.split(r"[-–—→\s]+", new_value)
        parts = [p.strip().title() for p in parts if p.strip()]
        new_value = " → ".join(parts)

    data['temp_data'][field] = new_value
    await state.update_data(temp_data=data['temp_data'])
    await state.set_state(Form.text_input)
    await show_verification_ui(message, data['temp_data'], state)

@dp.message(lambda message: message.text and not message.text.startswith('/'))
async def handle_unexpected_text(message: types.Message, state: FSMContext):
    current_state = await state.get_state()
    logger.debug(f"Получен текст вне ожидаемого состояния. Текст: '{message.text}'. Текущее состояние: {current_state}")
    if current_state != Form.text_input.state and current_state != Form.editing_field.state:
        await message.reply(
            "⚠️ Пожалуйста, сначала нажмите '📋 Запись', чтобы начать ввод данных.",
            reply_markup=create_main_menu()
        )

async def show_verification_ui(message: types.Message, data: dict, state: FSMContext):
    logger.debug("Показываем UI для проверки данных")
    builder = InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(text="✅ Верно", callback_data="confirm_yes"),
            InlineKeyboardButton(text="❌ Неверно", callback_data="confirm_no")
        ]
    ])
    formatted_data = "📋 Распознанные данные:\n\n"
    if "Водитель" in data:
        formatted_data += f"{hbold('Водитель')}:\n"
        formatted_data += f"  - ФИО: {data.get('Водитель', 'Не указан')}\n"
        if "Паспорт_серия_и_номер" in data and data["Паспорт_серия_и_номер"]:
            formatted_data += f"  - Паспорт: {data.get('Паспорт_серия_и_номер', '')}\n"
        if "Паспорт_место_выдачи_дата_код" in data and data["Паспорт_место_выдачи_дата_код"]:
            formatted_data += f"  - Паспорт_место_выдачи_дата_код: {data.get('Паспорт_место_выдачи_дата_код', '')}\n"
        if "В/У_серия_и_номер" in data and data["В/У_серия_и_номер"]:
            formatted_data += f"  - В/У: {data.get('В/У_серия_и_номер', '')}\n"
        if "В/У_дата_срок" in data and data["В/У_дата_срок"]:
            formatted_data += f"  - В/У_дата_срок: {data.get('В/У_дата_срок', '')}\n"
        if "Телефон" in data and data["Телефон"] != "Не указан":
            formatted_data += f"  - Телефон: {data.get('Телефон', 'Не указан')}\n"
        if "Дата рождения" in data and data["Дата рождения"]:
            formatted_data += f"  - Дата рождения: {data.get('Дата рождения', '')}\n"
        if "Адрес регистрации" in data and data["Адрес регистрации"]:
            formatted_data += f"  - Адрес регистрации: {data.get('Адрес регистрации', '')}\n"
    for key in ["Фирма", "Направление", "Перевозчик", "Цена", "Оплата"]:
        if key in data and data[key]:
            formatted_data += f"{hbold(key)}: {data.get(key, 'Не указан')}\n"
    if "Марка_машины_номер" in data or "Прицеп_номер" in data:
        formatted_data += f"{hbold('Марка машины')}:\n"
        if "Марка_машины_номер" in data and data["Марка_машины_номер"] != "Не указан":
            formatted_data += f"  - Автомобиль: {data.get('Марка_машины_номер', 'Не указан')}\n"
        if "Прицеп_номер" in data and data["Прицеп_номер"] != "Не указан":
            formatted_data += f"  - Прицеп: {data.get('Прицеп_номер', 'Не указан')}\n"

    await message.reply(
        formatted_data,
        reply_markup=builder,
        parse_mode="HTML"
    )
    await state.update_data(temp_data=data)

@dp.callback_query(lambda c: c.data == "confirm_yes")
async def handle_correct(callback: types.CallbackQuery, state: FSMContext):
    logger.debug("Пользователь подтвердил данные (✅ Верно)")
    data = await state.get_data()
    await save_record(callback.message, state, data["temp_data"])
    await callback.answer()

@dp.callback_query(lambda c: c.data == "confirm_no")
async def handle_incorrect(callback: types.CallbackQuery, state: FSMContext):
    logger.debug("Пользователь отклонил данные (❌ Неверно), показываем поля для редактирования")
    data = await state.get_data()
    builder = InlineKeyboardMarkup(inline_keyboard=[])
    field_groups = [
        ["Фирма", "Направление", "Перевозчик"],
        ["Водитель"],
        ["Паспорт_серия_и_номер", "Паспорт_место_выдачи_дата_код", "В/У_серия_и_номер", "В/У_дата_срок", "Телефон", "Дата рождения", "Адрес регистрации"],
        ["Марка_машины_номер", "Прицеп_номер"],
        ["Цена", "Оплата"]
    ]
    for group in field_groups:
        row_buttons = []
        for field in group:
            if field in data["temp_data"] and (field != "Прочее" or data["temp_data"].get(field)):
                row_buttons.append(
                    InlineKeyboardButton(
                        text=f"✏️ {field}",
                        callback_data=f"reedit_{field}"
                    )
                )
        if row_buttons:
            builder.inline_keyboard.append(row_buttons)
    await callback.message.edit_text(
        "Выберите поле для редактирования:",
        reply_markup=builder
    )

@dp.callback_query(lambda c: c.data.startswith("reedit_"))
async def reedit_field(callback: types.CallbackQuery, state: FSMContext):
    field = callback.data.split("_")[1]
    logger.debug(f"Пользователь выбрал редактирование поля: {field}")
    await state.update_data(editing_field=field)
    await state.set_state(Form.editing_field)
    
    hints = {
        "Фирма": "ТК Оптима",
        "Направление": "Москва → Питер",
        "Водитель": "Иванов И.И.",
        "Паспорт_серия_и_номер": "58 23 № 452205",
        "Паспорт_место_выдачи_дата_код": "УМВД, 11.05.2023, 600-002",
        "В/У_серия_и_номер": "99 21 № 980427",
        "В/У_дата_срок": "12.05.2021-24.09.2030",
        "Телефон": "911-359-75-34",
        "Дата рождения": "01.01.1990",
        "Адрес регистрации": "Москва, ул. Ленина, д.1",
        "Марка_машины_номер": "Volvo У444РУ60",
        "Прицеп_номер": "АУ548647",
        "Перевозчик": "ООО Ромашка",
        "Цена": "50000",
        "Оплата": "10000"
    }
    
    await callback.message.answer(
        f"Введите новое значение для <b>{field}</b> (пример: {hints.get(field, '')})",
        parse_mode="HTML"
    )

@dp.message(lambda message: message.text == "📆 Последние записи")
async def show_last_records(message: types.Message):
    logger.debug("Нажата кнопка '📆 Последние записи'")
    await message.reply("Функция пока в разработке.", reply_markup=create_main_menu())

@dp.message(lambda message: message.text == "📊 Статистика")
async def show_statistics(message: types.Message):
    logger.debug("Нажата кнопка '📊 Статистика'")
    try:
        excel_manager = ExcelManager(LOCAL_TEMP_DIR)
        daily_file = excel_manager.get_file_paths()['daily']
        if not os.path.exists(daily_file):
            await message.reply("📊 Статистика пока недоступна - нет данных", 
                               reply_markup=create_main_menu())
            return

        wb = load_workbook(daily_file)
        ws = wb.active
        total_records = ws.max_row - 1

        total_amount = 0
        total_payment = 0
        for row in ws.iter_rows(min_row=2, max_col=14, values_only=True):
            total_amount += row[12] if row[12] else 0
            total_payment += row[13] if row[13] else 0

        stats = (
            "📊 <b>Статистика за текущий месяц:</b>\n\n"
            f"🚚 Всего перевозок: {total_records}\n"
            f"💰 Общая сумма заказов: {total_amount:,.0f} ₽\n"
            f"💸 Общая сумма выплат: {total_payment:,.0f} ₽\n"
            f"⚖️ Средняя разница: {(total_amount - total_payment)/total_records:,.0f} ₽" if total_records > 0 else "⚖️ Средняя разница: 0 ₽"
        )
        await message.reply(stats, parse_mode="HTML",
                           reply_markup=create_main_menu())
    except Exception as e:
        logger.error(f"Ошибка статистики: {e}")
        await message.reply("❌ Ошибка при получении статистики",
                           reply_markup=create_main_menu())

async def save_record(message: types.Message, state: FSMContext, data: dict):
    logger.debug("Сохранение записи")
    defaults = {
        "Фирма": "Не указана",
        "Направление": "Не указано",
        "Водитель": "Не указан",
        "Паспорт_серия_и_номер": "",
        "Паспорт_место_выдачи_дата_код": "",
        "В/У_серия_и_номер": "",
        "В/У_дата_срок": "",
        "Телефон": "Не указан",
        "Марка_машины_номер": "Не указан",
        "Прицеп_номер": "Не указан",
        "Перевозчик": "Не указан",
        "Цена": 0,
        "Оплата": 0
    }
    data = {**defaults, **data}

    excel_manager = ExcelManager(LOCAL_TEMP_DIR)
    excel_manager.ensure_files_exist()
    success = excel_manager.add_record(
        excel_manager.get_file_paths()['daily'],
        data,
        'daily'
    )

    if success:
        uploader = YandexDiskUploader(y_disk)
        upload_success = await uploader.upload_files(
            list(excel_manager.get_file_paths().values()),
            message
        )

        status = "✅ Запись сохранена" + (
            " и загружена на Яндекс.Диск" if upload_success else ", но загрузка на Яндекс.Диск не удалась"
        )
    else:
        status = "❌ Ошибка сохранения"

    await message.reply(status, reply_markup=create_main_menu())
    await state.clear()

async def main():
    """Основная функция запуска бота"""
    try:
        if not y_disk.check_token():
            logger.error("Ошибка авторизации Яндекс.Диска")
            return
        await dp.start_polling(bot)
    except Exception as e:
        logger.critical(f"Критическая ошибка: {e}")
    finally:
        await bot.session.close()

if __name__ == "__main__":
    if os.name == 'nt':
        asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())
    asyncio.run(main())